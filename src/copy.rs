use std::path::{Path, PathBuf};
use std::fs;
use std::io::{self as stdio, Write};

use anyhow::{Context, Result};
use serde::{Serialize, Deserialize};

use crate::compare::ComparisonReport;

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyOp {
    pub src: String,
    pub dst: String,
    /// "copy" or "move" - we currently only implement copy
    pub op: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyPlan {
    pub ops: Vec<CopyOp>,
}

impl CopyPlan {
    pub fn new() -> Self {
        Self { ops: Vec::new() }
    }
}

/// Generate a copy plan from a ComparisonReport.
/// Behavior:
/// - For `changed` pairs (source, target) create copy from source.path -> target.path
/// - For `moved` pairs create copy from source.path -> target.path
/// - For `missing` entries (present in source but not in target) create copy from source.path -> corresponding target path.
///   If `source_root` and `target_root` are provided and the source path starts with `source_root` the target
///   path will be generated by replacing the prefix with `target_root`. Otherwise the destination will be the same as source.
pub fn generate_copy_plan(report: &ComparisonReport, source_root: Option<&Path>, target_root: Option<&Path>) -> CopyPlan {
    let mut plan = CopyPlan::new();

    // Handle changed files (explicit source -> target mapping)
    for (s, t) in &report.changed {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
        });
    }

    // Handle moved files (t.path exists in target)
    for (s, t) in &report.moved {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
        });
    }

    // Handle missing files (present in source but not in target) by constructing dst path
    for s in &report.missing {
        let src_p = Path::new(&s.path);
        let dst_str = if let (Some(sr), Some(tr)) = (source_root, target_root) {
            // Try to strip source_root from src path to create relative path
            if let Ok(rel) = src_p.strip_prefix(sr) {
                let candidate = tr.join(rel);
                candidate.to_string_lossy().into_owned()
            } else {
                // fallback to using same path
                s.path.clone()
            }
        } else {
            // No roots provided - fall back to using same path
            s.path.clone()
        };

        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: dst_str,
            op: "copy".into(),
        });
    }

    plan
}

/// Execute a copy plan performing filesystem operations.
/// For each operation:
/// - Ensure parent directories of destination exist
/// - Copy file contents
/// - Try to preserve file permissions
pub fn execute_copy_plan(plan: &CopyPlan) -> Result<()> {
    for op in &plan.ops {
        let src = Path::new(&op.src);
        let dst = Path::new(&op.dst);

        // Ensure source exists
        if !src.exists() {
            anyhow::bail!("source file does not exist: {}", src.display());
        }

        if let Some(parent) = dst.parent() {
            fs::create_dir_all(parent).with_context(|| format!("create parent dirs {:?}", parent))?;
        }

        // perform copy
        fs::copy(src, dst).with_context(|| format!("copy {:?} -> {:?}", src, dst))?;

        // preserve permissions if possible
        if let Ok(metadata) = fs::metadata(src) {
            let perms = metadata.permissions();
            if let Err(e) = fs::set_permissions(dst, perms) {
                // non-fatal; log to stderr
                let _ = writeln!(stdio::stderr(), "warning: failed to set permissions on {}: {}", dst.display(), e);
            }
        }
    }
    Ok(())
}

/// Print what would be done for a given plan.
pub fn dry_run_copy_plan(plan: &CopyPlan) {
    if plan.ops.is_empty() {
        println!("No copy operations to perform.");
        return;
    }
    println!("Planned copy operations:");
    for op in &plan.ops {
        println!("  {}: {} -> {}", op.op, op.src, op.dst);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn plan_generation_basic() {
        let mut r = ComparisonReport::new();
        r.changed.push((
            crate::io::MapEntry { path: "/src/a".into(), hash: "h".into(), size: 1 },
            crate::io::MapEntry { path: "/dst/a".into(), hash: "h2".into(), size: 1 },
        ));
        r.missing.push(crate::io::MapEntry { path: "/src/b".into(), hash: "h3".into(), size: 2 });

        let plan = generate_copy_plan(&r, Some(Path::new("/src")), Some(Path::new("/dst")));
        assert_eq!(plan.ops.len(), 2);
    }
}