use chrono::Utc;
use std::fs;
use std::io::{self as stdio, Write};
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use filetime::FileTime;
use serde::{Deserialize, Serialize};

use crate::compare::ComparisonReport;

#[derive(Debug, Clone, Copy)]
pub enum ConflictStrategy {
    Overwrite,
    Skip,
    Rename,
}

impl ConflictStrategy {
    pub fn from_name(s: &str) -> Option<Self> {
        s.parse().ok()
    }
}

impl std::str::FromStr for ConflictStrategy {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "overwrite" => Ok(ConflictStrategy::Overwrite),
            "skip" => Ok(ConflictStrategy::Skip),
            "rename" => Ok(ConflictStrategy::Rename),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct CopyOptions {
    pub conflict: ConflictStrategy,
    pub preserve_times: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyOp {
    pub src: String,
    pub dst: String,
    /// "copy" or "move" - we currently only implement copy
    pub op: String,
    #[serde(default)]
    pub done: bool,
    /// Optional status field to support resumable plans. When absent older plans
    /// using `done` will still be honored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub status: Option<CopyStatus>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum CopyStatus {
    Pending,
    InProgress,
    Done,
    Failed,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PlanMetadata {
    pub version: u8,
    pub generated_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_root: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_root: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyPlan {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub meta: Option<PlanMetadata>,
    pub ops: Vec<CopyOp>,
}

impl CopyPlan {
    pub fn new() -> Self {
        Self {
            meta: None,
            ops: Vec::new(),
        }
    }
}

impl Default for CopyPlan {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate a copy plan from a ComparisonReport.
/// Behavior:
/// - For `changed` pairs (source, target) create copy from source.path -> target.path
/// - For `moved` pairs create copy from source.path -> target.path
/// - For `missing` entries (present in source but not in target) create copy from source.path -> corresponding target path.
///   If `source_root` and `target_root` are provided and the source path starts with `source_root` the target
///   path will be generated by replacing the prefix with `target_root`. Otherwise the destination will be the same as source.
pub fn generate_copy_plan(
    report: &ComparisonReport,
    source_root: Option<&Path>,
    target_root: Option<&Path>,
) -> CopyPlan {
    let mut plan = CopyPlan::new();
    plan.meta = Some(PlanMetadata {
        version: 1,
        generated_at: Utc::now().to_rfc3339(),
        source_root: source_root.map(|p| p.to_string_lossy().into_owned()),
        target_root: target_root.map(|p| p.to_string_lossy().into_owned()),
    });

    // Handle changed files (explicit source -> target mapping)
    for (s, t) in &report.changed {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
            done: false,
            status: None,
        });
    }

    // Handle moved files (t.path exists in target)
    for (s, t) in &report.moved {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
            done: false,
            status: None,
        });
    }

    // Handle missing files (present in source but not in target) by constructing dst path
    for s in &report.missing {
        let src_p = Path::new(&s.path);
        let dst_str = if let (Some(sr), Some(tr)) = (source_root, target_root) {
            // Try to strip source_root from src path to create relative path
            if let Ok(rel) = src_p.strip_prefix(sr) {
                let candidate = tr.join(rel);
                candidate.to_string_lossy().into_owned()
            } else {
                // fallback to using same path
                s.path.clone()
            }
        } else {
            // No roots provided - fall back to using same path
            s.path.clone()
        };

        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: dst_str,
            op: "copy".into(),
            done: false,
            status: None,
        });
    }

    plan
}

pub fn write_plan(path: &Path, plan: &CopyPlan) -> Result<()> {
    crate::io::write_json(path, plan)
}

/// Execute a copy plan performing filesystem operations.
/// For each operation:
/// - Ensure parent directories of destination exist
/// - Copy file contents
/// - Try to preserve file permissions
fn resolve_destination(dst: &Path, strategy: ConflictStrategy) -> Result<Option<PathBuf>> {
    if !dst.exists() {
        return Ok(Some(dst.to_path_buf()));
    }
    match strategy {
        ConflictStrategy::Overwrite => Ok(Some(dst.to_path_buf())),
        ConflictStrategy::Skip => Ok(None),
        ConflictStrategy::Rename => {
            let mut idx = 1;
            let parent = dst.parent().unwrap_or(Path::new(""));
            let stem = dst
                .file_stem()
                .map(|s| s.to_string_lossy().into_owned())
                .unwrap_or_else(|| "copy".to_string());
            let ext = dst.extension().map(|s| s.to_string_lossy().into_owned());
            loop {
                let mut candidate = parent.join(format!("{}-copy{}", stem, idx));
                if let Some(e) = &ext {
                    candidate = candidate.with_extension(e);
                }
                if !candidate.exists() {
                    return Ok(Some(candidate));
                }
                idx += 1;
                if idx > 10_000 {
                    anyhow::bail!("unable to find unique name for {}", dst.display());
                }
            }
        }
    }
}

pub fn execute_copy_plan(
    plan: &mut CopyPlan,
    opts: CopyOptions,
    persist_path: Option<&Path>,
    git_diff: bool,
    include_patch: bool,
    context: usize,
    git_diff_output: Option<&Path>,
) -> Result<()> {
    for i in 0..plan.ops.len() {
        // take a short-lived mutable borrow for the current op
        if plan.ops[i].done || plan.ops[i].status == Some(CopyStatus::Done) {
            println!(
                "Skipping completed op {} -> {}",
                plan.ops[i].src, plan.ops[i].dst
            );
            continue;
        }
        // clone path strings to avoid holding immutable borrows while we mutate status
        let src_str = plan.ops[i].src.clone();
        let dst_str = plan.ops[i].dst.clone();
        let src = Path::new(&src_str);
        let dst = Path::new(&dst_str);

        // Ensure source exists
        if !src.exists() {
            // mark failed and persist (if requested) so user can inspect and resume later
            plan.ops[i].status = Some(CopyStatus::Failed);
            if let Some(path) = persist_path {
                write_plan(path, plan)?;
            }
            anyhow::bail!("source file does not exist: {}", src.display());
        }

        if let Some(parent) = dst.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("create parent dirs {:?}", parent))?;
        }

        let target_path = match resolve_destination(dst, opts.conflict)? {
            Some(p) => p,
            None => continue,
        };

        // mark in-progress and persist immediately (if requested)
        plan.ops[i].status = Some(CopyStatus::InProgress);
        if let Some(path) = persist_path {
            write_plan(path, plan)?;
        }

        // perform copy
        if let Err(e) = fs::copy(src, &target_path)
            .with_context(|| format!("copy {:?} -> {:?}", src, target_path))
        {
            // store failed status and persist before returning
            plan.ops[i].status = Some(CopyStatus::Failed);
            if let Some(path) = persist_path {
                write_plan(path, plan)?;
            }
            return Err(e);
        }

        if git_diff {
            let diff = crate::diff::format_copy_diff(
                src,
                &target_path,
                !dst.exists(),
                None,
                include_patch,
                context,
            );
            if let Some(out_path) = git_diff_output {
                // append to file
                if let Err(e) = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(out_path)
                    .and_then(|mut f| f.write_all(diff.as_bytes()))
                {
                    let _ = writeln!(
                        stdio::stderr(),
                        "warning: failed writing diff to {}: {}",
                        out_path.display(),
                        e
                    );
                }
            } else {
                println!("{}", diff);
            }
        }

        // preserve permissions if possible
        if let Ok(metadata) = fs::metadata(src) {
            let perms = metadata.permissions();
            if let Err(e) = fs::set_permissions(&target_path, perms) {
                // non-fatal; log to stderr
                let _ = writeln!(
                    stdio::stderr(),
                    "warning: failed to set permissions on {}: {}",
                    target_path.display(),
                    e
                );
            }

            if opts.preserve_times {
                if let (Ok(modified), Ok(accessed)) = (metadata.modified(), metadata.accessed()) {
                    let mtime = FileTime::from_system_time(modified);
                    let atime = FileTime::from_system_time(accessed);
                    if let Err(e) = filetime::set_file_times(&target_path, atime, mtime) {
                        let _ = writeln!(
                            stdio::stderr(),
                            "warning: failed to set timestamps on {}: {}",
                            target_path.display(),
                            e
                        );
                    }
                }
            }
        }
        plan.ops[i].done = true;
        plan.ops[i].status = Some(CopyStatus::Done);
        if let Some(path) = persist_path {
            // mutable borrow ended here; safe to write the plan
            write_plan(path, plan)?;
        }
    }
    Ok(())
}

/// Print what would be done for a given plan.
pub fn dry_run_copy_plan(
    plan: &CopyPlan,
    git_diff: bool,
    include_patch: bool,
    context: usize,
    git_diff_output: Option<&Path>,
) {
    if let Some(meta) = &plan.meta {
        println!("Plan generated at {}", meta.generated_at);
        if let Some(src) = &meta.source_root {
            println!("  source root: {}", src);
        }
        if let Some(dst) = &meta.target_root {
            println!("  target root: {}", dst);
        }
    }
    if plan.ops.is_empty() {
        println!("No copy operations to perform.");
        return;
    }
    if git_diff {
        for op in &plan.ops {
            let src = std::path::Path::new(&op.src);
            let dst = std::path::Path::new(&op.dst);
            let new_file = !dst.exists();
            let diff =
                crate::diff::format_copy_diff(src, dst, new_file, None, include_patch, context);
            if let Some(out_path) = git_diff_output {
                if let Err(e) = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(out_path)
                    .and_then(|mut f| f.write_all(diff.as_bytes()))
                {
                    let _ = writeln!(
                        stdio::stderr(),
                        "warning: failed writing diff to {}: {}",
                        out_path.display(),
                        e
                    );
                }
            } else {
                println!("{}", diff);
            }
        }
    } else {
        println!("Planned copy operations:");
        for op in &plan.ops {
            let status = if op.done { " (done)" } else { "" };
            println!("  {}: {} -> {}{}", op.op, op.src, op.dst, status);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn plan_generation_basic() {
        let mut r = ComparisonReport::new();
        r.changed.push((
            crate::io::MapEntry {
                path: "/src/a".into(),
                hash: "h".into(),
                size: 1,
                mtime: None,
            },
            crate::io::MapEntry {
                path: "/dst/a".into(),
                hash: "h2".into(),
                size: 1,
                mtime: None,
            },
        ));
        r.missing.push(crate::io::MapEntry {
            path: "/src/b".into(),
            hash: "h3".into(),
            size: 2,
            mtime: None,
        });

        let plan = generate_copy_plan(&r, Some(Path::new("/src")), Some(Path::new("/dst")));
        assert_eq!(plan.ops.len(), 2);
    }

    #[test]
    fn execute_copy_with_conflicts() {
        let dir = tempdir().unwrap();
        let src_dir = dir.path().join("src");
        let dst_dir = dir.path().join("dst");
        fs::create_dir_all(&src_dir).unwrap();
        fs::create_dir_all(&dst_dir).unwrap();

        let src_file = src_dir.join("file.txt");
        fs::write(&src_file, b"hello").unwrap();
        let dst_file = dst_dir.join("file.txt");
        fs::write(&dst_file, b"existing").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src_file.to_string_lossy().into_owned(),
            dst: dst_file.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        // Skip strategy should keep original
        let opts = CopyOptions {
            conflict: ConflictStrategy::Skip,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        let contents = fs::read(&dst_file).unwrap();
        assert_eq!(&contents, b"existing");

        // Rename strategy should create a new file beside existing one
        let opts = CopyOptions {
            conflict: ConflictStrategy::Rename,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        let renamed = dst_dir.join("file-copy1.txt");
        assert!(renamed.exists());
        let new_contents = fs::read(renamed).unwrap();
        assert_eq!(&new_contents, b"hello");
    }

    #[test]
    fn execute_copy_plan_persists_status_and_resume() {
        let dir = tempdir().unwrap();
        let src_dir = dir.path().join("src");
        let dst_dir = dir.path().join("dst");
        fs::create_dir_all(&src_dir).unwrap();
        fs::create_dir_all(&dst_dir).unwrap();

        let src_file = src_dir.join("file.txt");
        fs::write(&src_file, b"hello").unwrap();

        let plan_path = dir.path().join("plan.json");
        let mut plan = CopyPlan::new();
        plan.meta = Some(PlanMetadata {
            version: 1,
            generated_at: Utc::now().to_rfc3339(),
            source_root: None,
            target_root: None,
        });
        plan.ops.push(CopyOp {
            src: src_file.to_string_lossy().into_owned(),
            dst: dst_dir.join("file.txt").to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        // persist initial plan
        write_plan(&plan_path, &plan).unwrap();

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };

        // execute with persist_path should update status and done flags
        let mut loaded = plan;
        execute_copy_plan(&mut loaded, opts, Some(&plan_path), false, false, 3, None).unwrap();

        // read back persisted file
        let s = std::fs::read_to_string(&plan_path).unwrap();
        assert!(s.contains("\"status\": \"done\"") || s.contains("\"done\": true"));
    }

    #[test]
    fn empty_plan_executes_successfully() {
        let mut plan = CopyPlan::new();
        let opts = CopyOptions {
            conflict: ConflictStrategy::Skip,
            preserve_times: false,
        };
        let result = execute_copy_plan(&mut plan, opts, None, false, false, 3, None);
        assert!(result.is_ok());
    }

    #[test]
    fn plan_with_single_operation() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("src.txt");
        let dst = dir.path().join("dst.txt");
        fs::write(&src, b"content").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        assert!(dst.exists());
        assert_eq!(fs::read(&dst).unwrap(), b"content");
    }

    #[test]
    fn plan_creates_nested_directories() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("src.txt");
        let dst = dir.path().join("a/b/c/dst.txt");
        fs::write(&src, b"nested").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        assert!(dst.exists());
    }

    #[test]
    fn plan_handles_already_done_operations() {
        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: "/nonexistent/src".into(),
            dst: "/nonexistent/dst".into(),
            op: "copy".into(),
            done: true, // Already done
            status: Some(CopyStatus::Done),
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Skip,
            preserve_times: false,
        };
        let result = execute_copy_plan(&mut plan, opts, None, false, false, 3, None);
        assert!(result.is_ok());
    }

    #[test]
    fn plan_with_dry_run() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("src.txt");
        let dst = dir.path().join("dst.txt");
        fs::write(&src, b"test").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, true, false, 3, None).unwrap();
        // Dry run behavior - in dry run mode operations are marked but file ops may still occur
        // The important part is the function completes successfully
    }

    #[test]
    fn plan_preserves_timestamps() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("src.txt");
        let dst = dir.path().join("dst.txt");
        fs::write(&src, b"timestamp test").unwrap();

        // Set a specific modification time
        use std::time::{UNIX_EPOCH, Duration};
        let old_time = UNIX_EPOCH + Duration::from_secs(1000000);
        filetime::set_file_mtime(&src, filetime::FileTime::from_system_time(old_time)).unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: true,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();

        let src_metadata = fs::metadata(&src).unwrap();
        let dst_metadata = fs::metadata(&dst).unwrap();
        
        // Timestamps should match (within a second tolerance for filesystem granularity)
        let src_time = src_metadata.modified().unwrap();
        let dst_time = dst_metadata.modified().unwrap();
        let diff = src_time.duration_since(dst_time).unwrap_or(dst_time.duration_since(src_time).unwrap());
        assert!(diff < Duration::from_secs(2));
    }

    #[test]
    fn plan_with_large_file() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("large.bin");
        let dst = dir.path().join("large_copy.bin");
        
        // Create a 10 MB file
        let data = vec![0xAB; 10 * 1024 * 1024];
        fs::write(&src, &data).unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        
        assert!(dst.exists());
        assert_eq!(fs::metadata(&dst).unwrap().len(), 10 * 1024 * 1024);
    }

    #[test]
    fn plan_with_multiple_operations() {
        let dir = tempdir().unwrap();
        let src_dir = dir.path().join("src");
        let dst_dir = dir.path().join("dst");
        fs::create_dir_all(&src_dir).unwrap();
        fs::create_dir_all(&dst_dir).unwrap();

        // Create multiple source files
        for i in 0..10 {
            fs::write(src_dir.join(format!("file{}.txt", i)), format!("content{}", i)).unwrap();
        }

        let mut plan = CopyPlan::new();
        for i in 0..10 {
            plan.ops.push(CopyOp {
                src: src_dir.join(format!("file{}.txt", i)).to_string_lossy().into_owned(),
                dst: dst_dir.join(format!("file{}.txt", i)).to_string_lossy().into_owned(),
                op: "copy".into(),
                done: false,
                status: None,
            });
        }

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();

        // All files should be copied
        for i in 0..10 {
            assert!(dst_dir.join(format!("file{}.txt", i)).exists());
        }
    }

    #[test]
    fn plan_handles_empty_files() {
        let dir = tempdir().unwrap();
        let src = dir.path().join("empty.txt");
        let dst = dir.path().join("empty_copy.txt");
        fs::write(&src, b"").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src.to_string_lossy().into_owned(),
            dst: dst.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
            status: None,
        });

        let opts = CopyOptions {
            conflict: ConflictStrategy::Overwrite,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None, false, false, 3, None).unwrap();
        assert!(dst.exists());
        assert_eq!(fs::metadata(&dst).unwrap().len(), 0);
    }

    #[test]
    fn generate_plan_handles_empty_report() {
        let report = ComparisonReport::new();
        let plan = generate_copy_plan(&report, None, None);
        assert_eq!(plan.ops.len(), 0);
    }

    #[test]
    fn generate_plan_with_only_missing() {
        let mut report = ComparisonReport::new();
        report.missing.push(crate::io::MapEntry {
            path: "missing.txt".into(),
            hash: "hash".into(),
            size: 100,
            mtime: None,
        });

        let plan = generate_copy_plan(&report, Some(Path::new("/src")), Some(Path::new("/dst")));
        assert_eq!(plan.ops.len(), 1);
        assert_eq!(plan.ops[0].op, "copy");
    }

    #[test]
    fn generate_plan_with_only_changed() {
        let mut report = ComparisonReport::new();
        report.changed.push((
            crate::io::MapEntry {
                path: "changed.txt".into(),
                hash: "old".into(),
                size: 50,
                mtime: None,
            },
            crate::io::MapEntry {
                path: "changed.txt".into(),
                hash: "new".into(),
                size: 60,
                mtime: None,
            },
        ));

        let plan = generate_copy_plan(&report, Some(Path::new("/src")), Some(Path::new("/dst")));
        assert_eq!(plan.ops.len(), 1);
    }
}
