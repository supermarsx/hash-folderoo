use chrono::Utc;
use std::fs;
use std::io::{self as stdio, Write};
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use filetime::FileTime;
use serde::{Deserialize, Serialize};

use crate::compare::ComparisonReport;

#[derive(Debug, Clone, Copy)]
pub enum ConflictStrategy {
    Overwrite,
    Skip,
    Rename,
}

impl ConflictStrategy {
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "overwrite" => Some(ConflictStrategy::Overwrite),
            "skip" => Some(ConflictStrategy::Skip),
            "rename" => Some(ConflictStrategy::Rename),
            _ => None,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub struct CopyOptions {
    pub conflict: ConflictStrategy,
    pub preserve_times: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyOp {
    pub src: String,
    pub dst: String,
    /// "copy" or "move" - we currently only implement copy
    pub op: String,
    #[serde(default)]
    pub done: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PlanMetadata {
    pub version: u8,
    pub generated_at: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_root: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub target_root: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CopyPlan {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub meta: Option<PlanMetadata>,
    pub ops: Vec<CopyOp>,
}

impl CopyPlan {
    pub fn new() -> Self {
        Self {
            meta: None,
            ops: Vec::new(),
        }
    }
}

/// Generate a copy plan from a ComparisonReport.
/// Behavior:
/// - For `changed` pairs (source, target) create copy from source.path -> target.path
/// - For `moved` pairs create copy from source.path -> target.path
/// - For `missing` entries (present in source but not in target) create copy from source.path -> corresponding target path.
///   If `source_root` and `target_root` are provided and the source path starts with `source_root` the target
///   path will be generated by replacing the prefix with `target_root`. Otherwise the destination will be the same as source.
pub fn generate_copy_plan(
    report: &ComparisonReport,
    source_root: Option<&Path>,
    target_root: Option<&Path>,
) -> CopyPlan {
    let mut plan = CopyPlan::new();
    plan.meta = Some(PlanMetadata {
        version: 1,
        generated_at: Utc::now().to_rfc3339(),
        source_root: source_root.map(|p| p.to_string_lossy().into_owned()),
        target_root: target_root.map(|p| p.to_string_lossy().into_owned()),
    });

    // Handle changed files (explicit source -> target mapping)
    for (s, t) in &report.changed {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
            done: false,
        });
    }

    // Handle moved files (t.path exists in target)
    for (s, t) in &report.moved {
        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: t.path.clone(),
            op: "copy".into(),
            done: false,
        });
    }

    // Handle missing files (present in source but not in target) by constructing dst path
    for s in &report.missing {
        let src_p = Path::new(&s.path);
        let dst_str = if let (Some(sr), Some(tr)) = (source_root, target_root) {
            // Try to strip source_root from src path to create relative path
            if let Ok(rel) = src_p.strip_prefix(sr) {
                let candidate = tr.join(rel);
                candidate.to_string_lossy().into_owned()
            } else {
                // fallback to using same path
                s.path.clone()
            }
        } else {
            // No roots provided - fall back to using same path
            s.path.clone()
        };

        plan.ops.push(CopyOp {
            src: s.path.clone(),
            dst: dst_str,
            op: "copy".into(),
            done: false,
        });
    }

    plan
}

pub fn write_plan(path: &Path, plan: &CopyPlan) -> Result<()> {
    crate::io::write_json(path, plan)
}

/// Execute a copy plan performing filesystem operations.
/// For each operation:
/// - Ensure parent directories of destination exist
/// - Copy file contents
/// - Try to preserve file permissions
fn resolve_destination(dst: &Path, strategy: ConflictStrategy) -> Result<Option<PathBuf>> {
    if !dst.exists() {
        return Ok(Some(dst.to_path_buf()));
    }
    match strategy {
        ConflictStrategy::Overwrite => Ok(Some(dst.to_path_buf())),
        ConflictStrategy::Skip => Ok(None),
        ConflictStrategy::Rename => {
            let mut idx = 1;
            let parent = dst.parent().unwrap_or(Path::new(""));
            let stem = dst
                .file_stem()
                .map(|s| s.to_string_lossy().into_owned())
                .unwrap_or_else(|| "copy".to_string());
            let ext = dst.extension().map(|s| s.to_string_lossy().into_owned());
            loop {
                let mut candidate = parent.join(format!("{}-copy{}", stem, idx));
                if let Some(e) = &ext {
                    candidate = candidate.with_extension(e);
                }
                if !candidate.exists() {
                    return Ok(Some(candidate));
                }
                idx += 1;
                if idx > 10_000 {
                    anyhow::bail!("unable to find unique name for {}", dst.display());
                }
            }
        }
    }
}

pub fn execute_copy_plan(
    plan: &mut CopyPlan,
    opts: CopyOptions,
    persist_path: Option<&Path>,
) -> Result<()> {
    for i in 0..plan.ops.len() {
        // take a short-lived mutable borrow for the current op
        if plan.ops[i].done {
            println!(
                "Skipping completed op {} -> {}",
                plan.ops[i].src, plan.ops[i].dst
            );
            continue;
        }
        let src = Path::new(&plan.ops[i].src);
        let dst = Path::new(&plan.ops[i].dst);

        // Ensure source exists
        if !src.exists() {
            anyhow::bail!("source file does not exist: {}", src.display());
        }

        if let Some(parent) = dst.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("create parent dirs {:?}", parent))?;
        }

        let target_path = match resolve_destination(dst, opts.conflict)? {
            Some(p) => p,
            None => continue,
        };

        // perform copy
        fs::copy(src, &target_path)
            .with_context(|| format!("copy {:?} -> {:?}", src, target_path))?;

        // preserve permissions if possible
        if let Ok(metadata) = fs::metadata(src) {
            let perms = metadata.permissions();
            if let Err(e) = fs::set_permissions(&target_path, perms) {
                // non-fatal; log to stderr
                let _ = writeln!(
                    stdio::stderr(),
                    "warning: failed to set permissions on {}: {}",
                    target_path.display(),
                    e
                );
            }

            if opts.preserve_times {
                if let (Ok(modified), Ok(accessed)) = (metadata.modified(), metadata.accessed()) {
                    let mtime = FileTime::from_system_time(modified);
                    let atime = FileTime::from_system_time(accessed);
                    if let Err(e) = filetime::set_file_times(&target_path, atime, mtime) {
                        let _ = writeln!(
                            stdio::stderr(),
                            "warning: failed to set timestamps on {}: {}",
                            target_path.display(),
                            e
                        );
                    }
                }
            }
        }
        plan.ops[i].done = true;
        if let Some(path) = persist_path {
            // mutable borrow ended here; safe to write the plan
            write_plan(path, plan)?;
        }
    }
    Ok(())
}

/// Print what would be done for a given plan.
pub fn dry_run_copy_plan(plan: &CopyPlan) {
    if let Some(meta) = &plan.meta {
        println!("Plan generated at {}", meta.generated_at);
        if let Some(src) = &meta.source_root {
            println!("  source root: {}", src);
        }
        if let Some(dst) = &meta.target_root {
            println!("  target root: {}", dst);
        }
    }
    if plan.ops.is_empty() {
        println!("No copy operations to perform.");
        return;
    }
    println!("Planned copy operations:");
    for op in &plan.ops {
        let status = if op.done { " (done)" } else { "" };
        println!("  {}: {} -> {}{}", op.op, op.src, op.dst, status);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn plan_generation_basic() {
        let mut r = ComparisonReport::new();
        r.changed.push((
            crate::io::MapEntry {
                path: "/src/a".into(),
                hash: "h".into(),
                size: 1,
                mtime: None,
            },
            crate::io::MapEntry {
                path: "/dst/a".into(),
                hash: "h2".into(),
                size: 1,
                mtime: None,
            },
        ));
        r.missing.push(crate::io::MapEntry {
            path: "/src/b".into(),
            hash: "h3".into(),
            size: 2,
            mtime: None,
        });

        let plan = generate_copy_plan(&r, Some(Path::new("/src")), Some(Path::new("/dst")));
        assert_eq!(plan.ops.len(), 2);
    }

    #[test]
    fn execute_copy_with_conflicts() {
        let dir = tempdir().unwrap();
        let src_dir = dir.path().join("src");
        let dst_dir = dir.path().join("dst");
        fs::create_dir_all(&src_dir).unwrap();
        fs::create_dir_all(&dst_dir).unwrap();

        let src_file = src_dir.join("file.txt");
        fs::write(&src_file, b"hello").unwrap();
        let dst_file = dst_dir.join("file.txt");
        fs::write(&dst_file, b"existing").unwrap();

        let mut plan = CopyPlan::new();
        plan.ops.push(CopyOp {
            src: src_file.to_string_lossy().into_owned(),
            dst: dst_file.to_string_lossy().into_owned(),
            op: "copy".into(),
            done: false,
        });

        // Skip strategy should keep original
        let opts = CopyOptions {
            conflict: ConflictStrategy::Skip,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None).unwrap();
        let contents = fs::read(&dst_file).unwrap();
        assert_eq!(&contents, b"existing");

        // Rename strategy should create a new file beside existing one
        let opts = CopyOptions {
            conflict: ConflictStrategy::Rename,
            preserve_times: false,
        };
        execute_copy_plan(&mut plan, opts, None).unwrap();
        let renamed = dst_dir.join("file-copy1.txt");
        assert!(renamed.exists());
        let new_contents = fs::read(renamed).unwrap();
        assert_eq!(&new_contents, b"hello");
    }
}
